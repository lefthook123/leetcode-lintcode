CC 8.9
class Entry {
  String name;
  long created;
  long lastUpdated;
  long lastAccessed;
  Directory parent;
  int size;

  public Entry(String name,Directory parent){
    this.name=name;
    this.parent=parent;
    this.created=System.currentTimeMillis();
    this.lastUpdated=System.currentTimeMillis();
    this.LastAccessed=System.currentTimeMillis();
    this.size = 0;
  }
  public void changeName(String name){};
  public String getName(){};
  public abstract int getSize();
  public String path(){
    if(parent != null){
      return parent.path()+"/"+name;
    }
    return name;
  }
  
}

class File extends Entry {
  private String content;
  public File(String name,Directory parent,int size){
    super(n,p);
    this.size=size;
  }
  public void setContent(String content){};
  public String getContent(){};
  public int getSize();//
}



class Directory extends Entry{
  List<Entry> jj;
  public Directory(String name,Directory parent){
    super(name,parent);
      jj =new ArrayList<Entry>();
  }
  public int getSize(){
    int size=0;
    for(Entry en:jj){
      size+=en.getSize();//运行file里面的的 or directory的
    }
    return size;
  }
  public boolean delete(Entry en){
    return jj.remove(en);
  }
  public void add(Entry en){
    jj.add(en);
  }
  //ls directory => return jj;
  public List<Entry> ls(){};
}

CC 8.2

  public class ClassicSingleton* {

   private static ClassicSingleton* instance = null;
   private ClassicSingleton() {
      // Exists only to defeat instantiation.
   }
   public static ClassicSingleton getInstance() {
      if(instance == null) {
         instance = new ClassicSingleton();
      }
      return instance;
   }
}
===============================  


  
Call ==> CallerSystem => Employee  



class CallerSystem {
  
List<List<Employee>> canAccept;
List<List<Call>> callWait;//waiting list
private final int level=3;
private final int NUM_RESPONDENTS=10;
private final int NUM_MANAGER=10;
private final int NUM_DIRECTOR=10;
private static CallerSystem instance=null;
private CallerSystem(){
  
}
public static CallerSystem getInstance(){
  if(instance == null){
    instance=new CallerSystem();
  }
  return instance;
}
  
public Employee getAvailable(){}
public void dispatchCall(String caller){
  Call newCall = new Call(caller);
  disptachCall(newCall);
}
public void dispatchCall(Call call) {
  Employee empl=getAvailable();
  if(empl == null){//no one can accept the call
    callWait.get(call.getRank().getValue()).add(call);
  }else{
    empl.receiveCall(call);
    call.setEmployee(empl);
  }
}
  
  
===============  

class Employee
Call curCall;
Rank rank;
public void receiveCall(Call curCall){
  this.curCall=curCall;
}
public void disconnect(){
  this.curCall=null;
}
public void escalate() {
  ......
}
public Call getCall(){
  return this.curCall;
}

===============
  
 class Respondent extends Employee {
   public Respondent(){
     this.rank=Rank.RESPONDENT;
   }
 }
  
  
class Manager extends Employee {
  public Manager(){
    this.rank=Rank.MANAGER;
  }
  
}
  

class Director extends Employee {
    public Director(){
    this.rank=Rank.DIRECTOR;
  }
}
  
  
===============  
class Call 
==========
private Rank rank;
String caller;
private Employee handler;

public Call(String caller) {
  this.calller = caller;
  rank = Rank.RESPONDENT;
}
public void setEmployee(Employee employee){
  this.handler=employee;
}
getcaller;
public void setRank(Rank r){
  this.rank=r;
}

public void disconnect(){
  
}
public Rank getRank(){
  return rank;
}



public enum Rank{
  RESPONDENT(0), MANAGER(1),DIRECTOR(2);
  private int rank;
  private Rank(int rank){
    this.rank=rank;
  }
  public Rank getRank(){
    return this.rank;
  }
}
======================================================================

General Game
=================================================================
public class Board {
    Cell[][] board;
    public Board(int Nx, int Ny) {
        board = new Cell[Nx][Ny];
    }
    public boolean checkNeighbors(Cell currCell) {

        return true;
    }
//    public void initializeBoard()
}

public class Cell {
    private int x;
    private int y;
    boolean state;
    public Cell(int x, int y) {
        this.x = x;
        this. y = y;
        this.state = true;
    }
    public void updateCellState(boolean state){
        this.state = state;
    }

}
//Game of Life

public class GameOfLife {
    Board board;
    public void initializeGame(int Nx, int Ny) {
        board = new Board(Nx,Ny);
    }
    public void play() {
      
    }
    public static void main(String[] args)
    {


    }
}












然后直接考察 OO 编程, 也很基础, 写 牌 和 一副牌, 两个class, 在一副牌那里写发牌
               洗牌, 还有重新开始一副牌.
Deck of cards
=============================

  
public enum Type{
  Heart(0),Club(1),Spade(2),Diamond(3)
  private int val;
  private type(int val){
    this.val=val;
  }
  public int getVal(){
    return this.val;
  }
  public Type getType(){
    
  }
}

  
Card//每一张牌
==========
Type t;
private int value;//牌面上的值
private boolean aval;
public Card(Type t,int val);
public int getValue();
public int getType();
public void makeAvail(){ this.aval = true;} 
public void changeAvail(){this.aval=false;}


Player
======================
List<Card> hasCard;
private int score;
public Player(){};
public void getCard(Card card);//
public int getScore();


Game
=======================
List<Card> cards;
List<Player> player;
public Game(List<Card> cards,List<Player> player);
public void shuffle()//{
  int size=this.cards.size();
  for(int i=0;i<size;++i){
    Random rn = new Random();
    int answer = rn.nextInt(size-i)+i;//rn.nextInt(size)返回的值是0-(size-1)
    Card tmp=cards.get(i);
    cards.set(i,cards.get(answer));
    cards.set(answer,tmp);
  }
}
public void play(){
  
}

*/











Parking Lot
============
Stack<ParkingSpace> small,medium,large;
Map<Ticket,parkingSpace> map;
===============
Ticket Park(car){
  switch(car.size){
    case "small" :
        if(!small.isEmpty()){
            Ti t;
            ParkingSpace sp=small.pop();
            map.put(t,sp);
            sp.setCar(car);
          return t;
        }
        break;
    case "medium":
        break;
    case "large":
        break;
      return null;
  }
}
ParkingSpace unpark(Ticket t){
  ParkingSpace sp=map.get(t);
  Car car=sp.getCar();
  sp.setCar=null;
  map.remove(t);
  switch(car.size){
      small.push(sp);
  }
  
  return sp;
}

Parking Space
=============
enum size;
Car car;
int spaceNum;


Car
====
enum size;
String licenseId; 

Ticket
========
Car car;
int id;


=========================================================================
  TV
  
  
  Controller
    TV tv
    Request queue
  ============
    press()
    start()
  
  
=========================================================================


Elevator
========
int currFloor(state)
boolean upOrDown;
=============
run(request){
  
}
  


elevator controller
===============
Elevator elev;
elevatorrequest er;
==============
start(){
  while(){
    currReq= er.remove();
    elevator.run(currReq);
  }
  
}
press(request re){
  er.add(re);
}
  

  

  
elevatorrequest
===============
Queue<request> q;
===============
add();
remove();


request
========
  int start;
  int des;
  enum direction;
  
